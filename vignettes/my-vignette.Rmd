---
title: "CrossICC"
author: "Yu Sun"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

Cancer subtyping and prognosis have been studied extensively by various molecular profiling, such as genes, DNA methylation markers, proteins. With the data, unsupervised clustering are proven to be a well-established methodology for this purpose. However, most of clustering method requires users to define the optimal number of clusters and usually cancer subtypes resulting from a single dataset can not be replicated in external dataset. To address this issue, we present CrossICC, that implemented a previous published iterater-based clustering algorithm and also add a new strategy to improve the performance of the method. Particularly, [CrossICC](https://github.com/bioinformatist/CrossICC) utilizes an iterative strategy to derive the optimal gene set and cluster number from consensus similarity matrix generated by consensus clustering. [CrossICC](https://github.com/bioinformatist/CrossICC) is able to deal with multiple cross platform datasets so that requires no between-dataset normalizations. This package also provides abundant functions to help users visualize the identified subtypes and evaluate the subtyping performance. Specially, many cancer-related analysis methods are embedded to facilitate the clinical translation of the identified cancer subtypes.

There are two iteration based cluster modes provided by CrossICC, which are `balanced` clustering mode and `finer` clustering mode. For `balanced` mode, the core procedure is that samples from each platform are clustered seperately and  centroid of each subcluster derived were clustered again to generate super cluster. This process skipped the normalization step and avoided removing batch effect across platforms. Thus it can obtain more confidential gene signature as well as reliabe subtypes supported by larger data set. The details step by step illustration of this algorithm can be found in our previous published [paper](http://clincancerres.aacrjournals.org/content/early/2014/12/09/1078-0432.ccr-14-2481) and  our recent submitted paper[coming soon]. 
For `finer` mode, we are aiming to get more subtypes when samples comes groups that have high heterogeneity. Briefly, subclusters were first worked out by [ConsensusClusterPlus](https://bioconductor.org/packages/release/bioc/html/ConsensusClusterPlus.html) in each platform. We then calculated correlation coefficient between samples and centroids of clusters to get a new feature vector of each samples. Based on this new matrix, samples were devided into new clusters which are corresponding to final cancer subtypes.

## Example 1: To get super cluster from multiple platform sourced dataset

```{r eval=FALSE}
CrossICC.object <- CrossICC(example.matrices, max.iter = 20)
```

Here, `CrossICC.object` is a list object in R which contains results of each iteration before reaching convergence or given upper-limit time. For instance, `CrossICC.object[[1]]` stands for the result (gene signatures, super cluster and geneset group, etc.) produced by the 1st time iteration. Ditto the `CrossICC.object[[n]]`. If the iteration time comes to the user-defined upper-limit but still not reaches convergence, you will receive a warning message.

For the return value of `CrossICC()` has such a complicate structure that you should always assign the `CrossICC()`'s results to a variable, then use `summary.CrossICC()` for pretty/readable output in R console: 

By default, `CrossICC()` will run a shiny app once the iteration to help ...(Qi Fat please describe the shiny app here, detailed pls)

## Example 2: Summary the CrossICC-returned list to produce human-readable output

```{r eval=FALSE}
summary.CrossICC(CrossICC.object)
```

With `summary.CrossICC` you can get prettier output (also could be easy for using in further analysys) like:

```pre
$gene.signatures
      Cluster Genes     
 [1,] "K1"    "CCDC175" 
 [2,] "K1"    "ESYT3"   
 [3,] "K1"    "C10orf76"
 [4,] "K1"    "SLC38A1" 
 [5,] "K1"    "CLEC2A"  
 [6,] "K2"    "TMEM200C"
 [7,] "K2"    "SPANXN2" 
 [8,] "K2"    "SAMD4A"  
 [9,] "K2"    "TTLL9"   
[10,] "K1"    "APOB"    
[11,] "K1"    "PIAS4"   
[12,] "K1"    "HIP1R"   
[13,] "K2"    "NPIPB11" 
[14,] "K2"    "PLCXD2"  
[15,] "K2"    "SLC38A1" 
[16,] "K1"    "SAMD4A"  

$clusters
  GSM40651   GSM40652   GSM40653   GSM40654   GSM40655   GSM40656   GSM40657   GSM40658   GSM40659  GSM359831  GSM675619 
         1          2          1          1          1          1          2          2          2          1          2 
 GSM675625  GSM675628  GSM675630  GSM675650  GSM675652  GSM675659  GSM675661  GSM675662  GSM675663  GSM675664  GSM675665 
         1          1          1          1          1          1          1          1          1          1          2 
 GSM675666  GSM675667  GSM675668  GSM675669  GSM675670  GSM675671  GSM675672  GSM675673  GSM675674  GSM675675  GSM675681 
         2          2          2          2          2          2          2          2          2          2          2 
GSM1253682 GSM1253683 GSM1253684 GSM1253685 GSM1253686 GSM1253687 GSM1253688 GSM1253689 GSM1253690 GSM1253691 GSM1253692 
         2          2          1          2          1          1          1          1          1          2          2  
```

## Example 3: To get GSEA-like ranked matrix from CrossICC result

```{r eval=FALSE}
ssGSEA.matrix <- ssGSEA(example.matrices$x, CrossICC.object[[1]]$gene.signature, CrossICC.object[[1]]$unioned.genesets)
```

Qi Fat please describe ssGSEA here

## Example 4: To calculate the correlation between the predictor centroid and the validation centroid

```{r eval=FALSE}
predictor(example.matrices$x, ssGSEA.matrix, CrossICC.object[[1]]$gene.signature, CrossICC.object[[1]]$unioned.genesets)
```

Qi Fat please describe predictor here
